#include "move_gen.h"
#include "position.h"
#include "types.h"
#include "pieces.h"
#include "bitboard.h"
#include "attacks.h"
#include "consts.h"
#include "squares.h"
#include "attacks_manager.h"

void AddMove(MoveList *moveList, int sqFrom, int sqTo, int typeOfMove, int capturedPiece, unsigned promotion)
{
    moveList->moves[moveList->count].fromSq = sqFrom;
    moveList->moves[moveList->count].toSq = sqTo;
    moveList->moves[moveList->count].typeOfMove = typeOfMove;
    moveList->moves[moveList->count].capturedPiece = capturedPiece;
    moveList->moves[moveList->count].promotion = promotion;
    moveList->moves[moveList->count].castles = 0;
    moveList->count++;
}

void LoopPawnNonPromoMoves(U64 movesBitBoard, int offset, int typeOfMove, MoveList *moveList)
{
    for (; movesBitBoard > 0; movesBitBoard &= movesBitBoard - 1)
    {
        int sqTo = __builtin_ctzll(movesBitBoard);
        int sqFrom = sqTo + offset;
        AddMove(moveList, sqFrom, sqTo, typeOfMove, EMPTY, 0); // Captured piece will be fetched during make/unmakemove.
    }
}

void LoopPromoMoves(U64 movesBitBoard, int offset, MoveList *moveList)
{
    for (; movesBitBoard > 0; movesBitBoard &= movesBitBoard - 1)
    {
        int sqTo = __builtin_ctzll(movesBitBoard);
        int sqFrom = sqTo + offset;
        AddMove(moveList, sqFrom, sqTo, KNIGHT, EMPTY, 1);
        AddMove(moveList, sqFrom, sqTo, BISHOP, EMPTY, 1);
        AddMove(moveList, sqFrom, sqTo, ROOK, EMPTY, 1);
        AddMove(moveList, sqFrom, sqTo, QUEEN, EMPTY, 1);
    }
}

void GenerateQSearchMoves(Position *position, MoveList *moveList)
{
    int sideToMove = position->sideToMove;
    moveList->count = 0;
    const U64 enpassantSquare = position->enpassantSq;

    const U64 piecesOfColor = position->piecesByColor[sideToMove];
    const U64 enemyPieces = position->piecesByColor[(sideToMove ^ 1)];

    const U64 emptySquares = position->piecesByType[EMPTY];
    const U64 pawnsOfColor = piecesOfColor & position->piecesByType[PAWN];
    const U64 knightsOfColor = piecesOfColor & position->piecesByType[KNIGHT];
    const U64 bishopsOfColor = piecesOfColor & position->piecesByType[BISHOP];
    const U64 rooksOfColor = piecesOfColor & position->piecesByType[ROOK];
    const U64 queensOfColor = piecesOfColor & position->piecesByType[QUEEN];
    const U64 kingOfColor = piecesOfColor & position->piecesByType[KING];
    int forwardDirection = 8 - (16 * sideToMove);
    GenerateCaptureMoves(emptySquares, pawnsOfColor, knightsOfColor, bishopsOfColor, rooksOfColor, queensOfColor, kingOfColor, enemyPieces, enpassantSquare, sideToMove, forwardDirection, moveList);
}
void GenerateMoves(Position *position, MoveList *moveList)
{
    int sideToMove = position->sideToMove;
    moveList->count = 0;
    const U64 enpassantSquare = position->enpassantSq;
    const U64 castlePermissions = position->castleRights[sideToMove];
    const U64 piecesOfColor = position->piecesByColor[sideToMove];
    const U64 enemyPieces = position->piecesByColor[(sideToMove ^ 1)];

    const U64 emptySquares = position->piecesByType[EMPTY];
    const U64 occupied = ~emptySquares;
    const U64 pawnsOfColor = piecesOfColor & position->piecesByType[PAWN];
    const U64 knightsOfColor = piecesOfColor & position->piecesByType[KNIGHT];
    const U64 bishopsOfColor = piecesOfColor & position->piecesByType[BISHOP];
    const U64 rooksOfColor = piecesOfColor & position->piecesByType[ROOK];
    const U64 queensOfColor = piecesOfColor & position->piecesByType[QUEEN];
    const U64 kingOfColor = piecesOfColor & position->piecesByType[KING];

    int forwardDirection = 8 - (16 * sideToMove);
    // U64 castleConstsShort = CastleRightsConsts[2 * sideToMove];
    // U64 castleConstsLong = CastleRightsConsts[(2 * sideToMove) + 1];

    GenerateCaptureMoves(emptySquares, pawnsOfColor, knightsOfColor, bishopsOfColor, rooksOfColor, queensOfColor, kingOfColor, enemyPieces, enpassantSquare, sideToMove, forwardDirection, moveList);
    GenerateNonCaptureMoves(emptySquares, pawnsOfColor, knightsOfColor, bishopsOfColor, rooksOfColor, queensOfColor, kingOfColor, sideToMove, forwardDirection, moveList);

    if (sideToMove == COLOR_WHITE)
    {
        if ((castlePermissions & WhiteKingsideRookBit) && ((0x60UL & occupied) == 0) && (!IsSquareAttacked(SQ_E1, position)) && (!IsSquareAttacked(SQ_F1, position)))
        {
            moveList->moves[moveList->count].castles = 1;
            moveList->moves[moveList->count].typeOfMove = KING;
            moveList->moves[moveList->count].fromSq = SQ_E1;
            moveList->moves[moveList->count].toSq = SQ_G1;
            moveList->count++;
        }

        if ((castlePermissions & WhiteQueensideRookBit) && ((0xeUL & occupied) == 0) && (!IsSquareAttacked(SQ_E1, position)) && (!IsSquareAttacked(SQ_D1, position)))
        {
            moveList->moves[moveList->count].castles = 2;
            moveList->moves[moveList->count].typeOfMove = KING;
            moveList->moves[moveList->count].fromSq = SQ_E1;
            moveList->moves[moveList->count].toSq = SQ_C1;
            moveList->count++;
        }
    }
    else
    {
        if ((castlePermissions & BlackKingsideRookBit) && ((0x6000000000000000UL & occupied) == 0) && (!IsSquareAttacked(SQ_E8, position)) && (!IsSquareAttacked(SQ_F8, position)))
        {
            moveList->moves[moveList->count].castles = 4;
            moveList->moves[moveList->count].typeOfMove = KING;
            moveList->moves[moveList->count].fromSq = SQ_E8;
            moveList->moves[moveList->count].toSq = SQ_G8;
            moveList->count++;
        }

        if ((castlePermissions & BlackQueensideRookBit) && ((0xe00000000000000UL & occupied) == 0) && (!IsSquareAttacked(SQ_E8, position)) && (!IsSquareAttacked(SQ_D8, position)))
        {
            moveList->moves[moveList->count].castles = 8;
            moveList->moves[moveList->count].typeOfMove = KING;
            moveList->moves[moveList->count].fromSq = SQ_E8;
            moveList->moves[moveList->count].toSq = SQ_C8;
            moveList->count++;
        }
    }
}

void GenerateCaptureMoves(U64 emptySquares, U64 pawnsOfColor, U64 knightsOfColor, U64 bishopsOfColor, U64 rooksOfColor, U64 queensOfColor, U64 kingOfColor, U64 enemyPieces, U64 enpassantSquare, int sideToMove, int forwardDirection, MoveList *moveList)
{
    GeneratePawnCapturesMoves(pawnsOfColor, (enemyPieces | enpassantSquare), sideToMove, forwardDirection, moveList);
    GenerateKnightMoves(knightsOfColor, enemyPieces, sideToMove, moveList);
    GenerateKingMoves(kingOfColor, enemyPieces, sideToMove, moveList);
    GenerateBishopMoves(bishopsOfColor, enemyPieces, ~emptySquares, sideToMove, moveList);
    GenerateRookMoves(rooksOfColor, enemyPieces, ~emptySquares, sideToMove, moveList);
    GenerateQueenMoves(queensOfColor, enemyPieces, ~emptySquares, sideToMove, moveList);
}

void GenerateNonCaptureMoves(U64 emptySquares, U64 pawnsOfColor, U64 knightsOfColor, U64 bishopsOfColor, U64 rooksOfColor, U64 queensOfColor, U64 kingOfColor, int sideToMove, int forwardDirection, MoveList *moveList)
{
    GeneratePawnNonCapturesMoves(pawnsOfColor, emptySquares, sideToMove, forwardDirection, moveList);
    GenerateKnightMoves(knightsOfColor, emptySquares, sideToMove, moveList);
    GenerateKingMoves(kingOfColor, emptySquares, sideToMove, moveList);
    GenerateBishopMoves(bishopsOfColor, emptySquares, ~emptySquares, sideToMove, moveList);
    GenerateRookMoves(rooksOfColor, emptySquares, ~emptySquares, sideToMove, moveList);
    GenerateQueenMoves(queensOfColor, emptySquares, ~emptySquares, sideToMove, moveList);
}

void GeneratePawnNonCapturesMoves(U64 pawnsOfColor, U64 emptySquares, int sideToMove, int forwardDirection, MoveList *moveList)
{
    U64 pawnMoves = ((pawnsOfColor << 8) >> (16 * sideToMove)) & emptySquares;
    // Pawn promotions.
    U64 promotingPawns = pawnMoves & SIDE_RANKS[sideToMove][RANK_8];
    // Single push.
    U64 singlePawnPush = pawnMoves ^ promotingPawns;
    // Double push candidates.
    U64 doublePawnPush = (((singlePawnPush & SIDE_RANKS[sideToMove][RANK_3]) << 8) >> (16 * sideToMove)) & emptySquares;
    // Add them in moveList.
    LoopPromoMoves(promotingPawns, -forwardDirection, moveList);
    LoopPawnNonPromoMoves(singlePawnPush, -forwardDirection, PAWN, moveList);
    LoopPawnNonPromoMoves(doublePawnPush, -(forwardDirection << 1), PAWN, moveList);
}

void GenerateKnightMoves(U64 knightsOfColor, U64 targetSquares, int sideToMove, MoveList *moveList)
{
    for (; knightsOfColor > 0; knightsOfColor &= knightsOfColor - 1)
    {
        int sqFrom = __builtin_ctzll(knightsOfColor);
        int capturedPiece = EMPTY;

        U64 knightAttacksFromSquare = KNIGHT_ATTACKS[sqFrom] & targetSquares;

        for (; knightAttacksFromSquare > 0; knightAttacksFromSquare &= knightAttacksFromSquare - 1)
        {
            int sqTo = __builtin_ctzll(knightAttacksFromSquare);
            AddMove(moveList, sqFrom, sqTo, KNIGHT, capturedPiece, 0);
        }
    }
}

void GenerateKingMoves(U64 kingOfColor, U64 targetSquares, int sideToMove, MoveList *moveList)
{
    for (; kingOfColor > 0; kingOfColor &= kingOfColor - 1)
    {
        int sqFrom = __builtin_ctzll(kingOfColor);
        U64 kingAttacksFromSquare = KING_ATTACKS[sqFrom] & targetSquares;

        for (; kingAttacksFromSquare > 0; kingAttacksFromSquare &= kingAttacksFromSquare - 1)
        {
            int sqTo = __builtin_ctzll(kingAttacksFromSquare);
            AddMove(moveList, sqFrom, sqTo, KING, EMPTY, 0);
        }
    }
}

void GenerateBishopMoves(U64 bishopsOfColor, U64 targetSquares, U64 occupied, int sideToMove, MoveList *moveList)
{
    for (; bishopsOfColor > 0; bishopsOfColor &= bishopsOfColor - 1)
    {
        int sqFrom = __builtin_ctzll(bishopsOfColor);
        U64 bishopAttacksFromSquare = GenerateBishopAttacks(sqFrom, occupied) & targetSquares;
        for (; bishopAttacksFromSquare > 0; bishopAttacksFromSquare &= bishopAttacksFromSquare - 1)
        {
            int sqTo = __builtin_ctzll(bishopAttacksFromSquare);
            AddMove(moveList, sqFrom, sqTo, BISHOP, EMPTY, 0);
        }
    }
}

void GenerateRookMoves(U64 rooksOfColor, U64 targetSquares, U64 occupied, int sideToMove, MoveList *moveList)
{
    for (; rooksOfColor > 0; rooksOfColor &= rooksOfColor - 1)
    {
        int sqFrom = __builtin_ctzll(rooksOfColor);
        U64 rookAttacksFromSquare = GenerateRookAttacks(sqFrom, occupied) & targetSquares;
        for (; rookAttacksFromSquare > 0; rookAttacksFromSquare &= rookAttacksFromSquare - 1)
        {
            int sqTo = __builtin_ctzll(rookAttacksFromSquare);
            AddMove(moveList, sqFrom, sqTo, ROOK, EMPTY, 0);
        }
    }
}
void GenerateQueenMoves(U64 queensOfColor, U64 targetSquares, U64 occupied, int sideToMove, MoveList *moveList)
{

    for (; queensOfColor > 0; queensOfColor &= queensOfColor - 1)
    {
        int sqFrom = __builtin_ctzll(queensOfColor);

        U64 queenAttacksFromSquare = (GenerateRookAttacks(sqFrom, occupied) | GenerateBishopAttacks(sqFrom, occupied)) & targetSquares;

        for (; queenAttacksFromSquare > 0; queenAttacksFromSquare &= queenAttacksFromSquare - 1)
        {
            int sqTo = __builtin_ctzll(queenAttacksFromSquare);
            AddMove(moveList, sqFrom, sqTo, QUEEN, EMPTY, 0);
        }
    }
}

// Generate capture moves.
void GeneratePawnCapturesMoves(U64 pawnsOfColor, U64 enemyPieces, int sideToMove, int forwardDirection, MoveList *moveList)
{
    // Consider normal promotions here as well as promotions after captures since they are not quiet moves.

    // Capture left from white's perspective.
    U64 pawnCaptures = (((pawnsOfColor & BB_NOT_FILE_A) << 7) >> (16 * sideToMove)) & (enemyPieces);
    U64 pawnCapturesPromoting = pawnCaptures & SIDE_RANKS[sideToMove][RANK_8];
    U64 pawnCapturesNonPromoting = pawnCaptures ^ pawnCapturesPromoting;

    LoopPawnNonPromoMoves(pawnCapturesNonPromoting, (-forwardDirection + 1), PAWN, moveList);
    LoopPromoMoves(pawnCapturesPromoting, (-forwardDirection + 1), moveList);
    // Capture right from whites perspective.
    pawnCaptures = (((pawnsOfColor & BB_NOT_FILE_H) << 9) >> (16 * sideToMove)) & (enemyPieces);
    pawnCapturesPromoting = pawnCaptures & SIDE_RANKS[sideToMove][RANK_8];
    pawnCapturesNonPromoting = pawnCaptures ^ pawnCapturesPromoting;
    LoopPawnNonPromoMoves(pawnCapturesNonPromoting, (-forwardDirection - 1), PAWN, moveList);
    LoopPromoMoves(pawnCapturesPromoting, (-forwardDirection - 1), moveList);
}

// Generate castling moves.
void GenerateCastlingMoves()
{
}